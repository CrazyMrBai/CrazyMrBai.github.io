---
layout:     post
title:      Androidå­¦ä¹ 
subtitle:   Magiskæºç å­¦ä¹ 
date:       2023-05-26
author:     CrazyRabbit
header-img: img/post-bg-debug.png
catalog: true
tags:
- Android
- Magisk
---

#### ä¸€ã€ã€rootçš„å‰ä¸–ä»Šç”Ÿ


1ã€ä»€ä¹ˆæ˜¯root
> root æŒ‡çš„æ˜¯ä½¿ç”¨æˆ·å–å¾— Android æ“ä½œç³»ç»Ÿçš„è¶…çº§ç”¨æˆ·ï¼ˆSuper Userï¼‰è®¸å¯æƒçš„æŠ€æœ¯ã€‚ç”¨æˆ·é€šè¿‡ rootï¼Œå¯ä»¥è¶Šè¿‡æ‰‹æœºåˆ¶é€ å•†çš„é™åˆ¶ï¼Œå¸è½½æ‰‹æœºåˆ¶é€ å•†é¢„è£…åœ¨æ‰‹æœºä¸­æŸäº›åº”ç”¨ï¼Œä»¥åŠè¿è¡Œä¸€äº›éœ€è¦è¶…çº§ç”¨æˆ·æƒé™çš„åº”ç”¨ç¨‹åºã€‚åŒæ—¶,root ä¹Ÿå¯èƒ½ä¼šè®©æ‰‹æœºå˜å¾—â€œä¸å®‰å…¨â€ï¼ˆå¹¶ä¸æ˜¯è¯´ root ä½¿æ‰‹æœºå˜å¾—ä¸å®‰å…¨ï¼Œè€Œæ˜¯ä¸€äº›ç”¨æˆ·çš„ä½¿ç”¨ä¹ æƒ¯ä¼šä½¿ root åçš„æ‰‹æœºå˜å¾—å±é™©ï¼‰ä½†æ˜¯ä»æ£‰èŠ±ç³–ï¼ˆAndroid 6.0ï¼‰å¼€å§‹ï¼ŒGoogle åŸºæœ¬é˜»æ­¢äº†ä»¥å‰ç‰ˆæœ¬ä¸­æœ€æµè¡Œçš„ root æ–¹æ³• â€”â€” å³ï¼Œå°† suå®ˆæŠ¤ç¨‹åº æ”¾ç½®åˆ° /system åˆ†åŒºï¼Œå¹¶åœ¨å¯åŠ¨æ—¶å–å¾—æ‰€éœ€çš„æƒé™ã€‚

> ---ç»´åŸºç™¾ç§‘  
2ã€å¸¸è§çš„è·å–rootçš„æ–¹å¼  
a æœ€åˆçš„æ–¹å¼ åœ¨Android 4.3 ä¹‹å‰ æˆ‘ä»¬åªè¦å°†ä¸€ä¸ªsuçš„äºŒè¿›åˆ¶ç¨‹åºæ”¾åˆ°systemç›®å½•ä¸‹çš„ç¯å¢ƒå˜é‡ä¸­å³å¯è·å¾—rootæƒé™ï¼Œ**åŠ«æŒä¸€ä¸ªæœ‰rootæƒé™çš„è¿›ç¨‹**ï¼Œåˆ©ç”¨å…¶å°†suæ–‡ä»¶æ¨å…¥ï¼Œå¹¶ç»™äºˆç›¸å…³æƒé™ï¼Œä½†æ˜¯Android4.3ä¹‹åçš„å®‰å…¨å¢å¼ºåŠŸèƒ½å¯¼è‡´è¯¥æ–¹æ¡ˆä¸å¯ç”¨

- **é€šè¿‡ SELinux å¾—åˆ°å¢å¼ºçš„ Android æ²™ç›’ã€‚**æ­¤ç‰ˆæœ¬åˆ©ç”¨ Linux å†…æ ¸ä¸­çš„ SELinux å¼ºåˆ¶è®¿é—®æ§åˆ¶ç³»ç»Ÿ (MAC) å¢å¼ºäº† Android æ²™ç›’ã€‚SELinux å¼ºåŒ–åŠŸèƒ½ï¼ˆç”¨æˆ·å’Œå¼€å‘è€…çœ‹ä¸åˆ°å®ƒï¼‰å¯æé«˜ç°æœ‰ Android å®‰å…¨æ¨¡å‹çš„å¯é æ€§ï¼ŒåŒæ—¶ä¸ç°æœ‰åº”ç”¨ä¿æŒå…¼å®¹ã€‚ä¸ºäº†ç¡®ä¿æŒç»­å…¼å®¹ï¼Œæ­¤ç‰ˆæœ¬å…è®¸ä»¥å®½å®¹æ¨¡å¼ä½¿ç”¨ SELinuxã€‚æ­¤æ¨¡å¼ä¼šè®°å½•æ‰€æœ‰æ”¿ç­–è¿è§„è¡Œä¸ºï¼Œä½†ä¸ä¼šä¸­æ–­åº”ç”¨æˆ–å½±å“ç³»ç»Ÿè¡Œä¸ºã€‚
- **æ²¡æœ‰ SetUID/SetGID ç¨‹åºã€‚**é’ˆå¯¹ Android ç³»ç»Ÿæ–‡ä»¶æ·»åŠ äº†å¯¹æ–‡ä»¶ç³»ç»ŸåŠŸèƒ½çš„æ”¯æŒï¼Œå¹¶ç§»é™¤äº†æ‰€æœ‰ SetUID/SetGUID ç¨‹åºã€‚è¿™å¯ä»¥å‡å° Root æ”»å‡»é¢ï¼Œå¹¶é™ä½å‡ºç°æ½œåœ¨å®‰å…¨æ¼æ´çš„å¯èƒ½æ€§ã€‚
- **ADB èº«ä»½éªŒè¯ã€‚**ä» Android 4.2.2 èµ·ï¼Œå¼€å§‹ä½¿ç”¨ RSA å¯†é’¥å¯¹ä¸º ADB è¿æ¥è¿›è¡Œèº«ä»½éªŒè¯ã€‚è¿™å¯ä»¥é˜²æ­¢æ”»å‡»è€…åœ¨å®é™…æ¥è§¦åˆ°è®¾å¤‡çš„æƒ…å†µä¸‹æœªç»æˆæƒä½¿ç”¨ ADBã€‚
- **é™åˆ¶ Android åº”ç”¨æ‰§è¡Œ SetUID ç¨‹åºã€‚**/system åˆ†åŒºç°åœ¨é’ˆå¯¹ Zygote è¡ç”Ÿçš„è¿›ç¨‹è£…è½½äº† nosuidï¼Œä»¥é˜²æ­¢ Android åº”ç”¨æ‰§è¡Œ SetUID ç¨‹åºã€‚è¿™å¯ä»¥å‡å° Root æ”»å‡»é¢ï¼Œå¹¶é™ä½å‡ºç°æ½œåœ¨å®‰å…¨æ¼æ´çš„å¯èƒ½æ€§ã€‚
- **åŠŸèƒ½ç»‘å®šã€‚**åœ¨æ‰§è¡Œåº”ç”¨ä¹‹å‰ï¼ŒAndroid Zygote å’Œ ADB ç°åœ¨ä¼šå…ˆä½¿ç”¨ prctl(PR_CAPBSET_DROP) èˆå¼ƒä¸å¿…è¦çš„åŠŸèƒ½ã€‚è¿™å¯ä»¥é˜²æ­¢ Android åº”ç”¨å’Œä» shell å¯åŠ¨çš„åº”ç”¨è·å–ç‰¹æƒåŠŸèƒ½ã€‚
- **AndroidKeyStore æä¾›ç¨‹åºã€‚**Android ç°åœ¨æœ‰ä¸€ä¸ªå…è®¸åº”ç”¨åˆ›å»ºä¸“ç”¨å¯†é’¥çš„å¯†é’¥åº“æä¾›ç¨‹åºã€‚è¯¥ç¨‹åºå¯ä»¥ä¸ºåº”ç”¨æä¾›ä¸€ä¸ªç”¨äºåˆ›å»ºæˆ–å­˜å‚¨ç§é’¥çš„ APIï¼Œå…¶ä»–åº”ç”¨å°†æ— æ³•ä½¿ç”¨è¿™äº›ç§é’¥ã€‚
- **KeyChain isBoundKeyAlgorithmã€‚**Keychain API ç°åœ¨æä¾›äº†ä¸€ç§æ–¹æ³• (isBoundKeyType)ï¼Œå¯è®©åº”ç”¨ç¡®è®¤ç³»ç»Ÿçº§å¯†é’¥æ˜¯å¦å·²ç»‘å®šåˆ°è®¾å¤‡çš„ç¡¬ä»¶ä¿¡ä»»æ ¹ã€‚è¯¥æ–¹æ³•æä¾›äº†ä¸€ä¸ªç”¨äºåˆ›å»ºæˆ–å­˜å‚¨ç§é’¥çš„ä½ç½®ï¼Œå³ä½¿ Root æƒé™è¢«çªƒå–ï¼Œè¿™äº›ç§é’¥ä¹Ÿæ— æ³•ä»è®¾å¤‡ä¸­å¯¼å‡ºã€‚
- **NO_NEW_PRIVSã€‚**åœ¨æ‰§è¡Œåº”ç”¨ä»£ç ä¹‹å‰ï¼ŒAndroid Zygote ç°åœ¨ä¼šå…ˆä½¿ç”¨ prctl(PR_SET_NO_NEW_PRIVS) ç¦æ­¢æ·»åŠ æ–°æƒé™ã€‚è¿™å¯ä»¥é˜²æ­¢ Android åº”ç”¨æ‰§è¡Œå¯é€šè¿‡ execve ææƒçš„æ“ä½œã€‚ï¼ˆæ­¤åŠŸèƒ½éœ€è¦ä½¿ç”¨ 3.5 æˆ–æ›´é«˜ç‰ˆæœ¬çš„ Linux å†…æ ¸ï¼‰ã€‚

b SuperSu ä¿®æ”¹å†…éƒ¨åˆ†åŒº æŒ‚è½½è‡ªå·±çš„åˆ†åŒºï¼Œå¯æƒœè¯¥æ–¹æ¡ˆé—­æºäº†

c åˆ©ç”¨ä¸‰æ–¹å®šåˆ¶recovery

d mlsçš„æ–¹æ¡ˆ ä¿®æ”¹vendoråˆ†åŒºï¼Œæ„å»ºä¸€ä¸ªè‡ªå·±çš„usæœåŠ¡,è¿™é‡Œå·²ç»æ˜¯ç®€æ˜“ç‰ˆçš„Magiskï¼ˆæ²¡æœ‰å®šåˆ¶çš„selinuxğŸ˜­ï¼‰

#### äºŒã€Magiskä»‹ç»


1ã€é¦–æ¬¡åˆ·å…¥Magiskï¼ŒMagiskåšäº†ä»€ä¹ˆï¼Ÿ


1.1 åˆ†åŒºçš„æ¦‚å¿µ

Android è®¾å¤‡åŒ…å«è‹¥å¹²ä¸ªåˆ†åŒºï¼Œè¿™äº›åˆ†åŒºåœ¨å¯åŠ¨è¿‡ç¨‹ä¸­å‘æŒ¥ä¸åŒçš„ä½œç”¨ã€‚ä¸ºäº†æ”¯æŒÂ [A/B æ›´æ–°](https://source.android.google.cn/devices/tech/ota/ab?hl=zh-cn)ï¼Œè®¾å¤‡éœ€è¦ä¸ºÂ bootã€systemã€vendorÂ å’ŒÂ radioÂ åˆ†åŒºåˆ†åˆ«å•ç‹¬é…ç½®ä¸€ä¸ªæ§½ä½ã€‚


- **boot**ï¼šboot åˆ†åŒºåŒ…å«é€šè¿‡ mkbootimg ç»„åˆåœ¨ä¸€èµ·çš„å†…æ ¸æ˜ åƒå’Œ RAM ç£ç›˜ã€‚ä¸ºäº†ç›´æ¥åˆ·å†™å†…æ ¸è€Œä¸åˆ·å†™æ–°çš„ boot åˆ†åŒºï¼Œå¯ä»¥ä½¿ç”¨è™šæ‹Ÿåˆ†åŒºï¼š
    - **kernel**ï¼škernel è™šæ‹Ÿåˆ†åŒºä»…è¦†ç›–å†…æ ¸ï¼ˆzImageã€zImage-dtbã€Image.gz-dtbï¼‰ï¼Œæ–¹æ³•æ˜¯å†™å…¥æ–°çš„æ˜ åƒæ¥è¦†ç›–æ—§çš„æ˜ åƒã€‚ä¸ºæ­¤ï¼Œå®ƒä¼šç¡®å®š eMMC ä¸­ç°æœ‰å†…æ ¸æ˜ åƒçš„èµ·å§‹ä½ç½®å¹¶å°†æ–°å†…æ ¸æ˜ åƒå¤åˆ¶åˆ°è¯¥ä½ç½®ã€‚è¯·è®°ä½ï¼Œæ–°å†…æ ¸æ˜ åƒå¯èƒ½ä¼šå¤§äºç°æœ‰å†…æ ¸æ˜ åƒã€‚å¼•å¯¼åŠ è½½ç¨‹åºå¯ä»¥é€šè¿‡ç§»åŠ¨å…¶åçš„ä»»ä½•æ•°æ®æ¥è…¾å‡ºç©ºé—´æˆ–æ”¾å¼ƒå‡ºé”™çš„æ“ä½œã€‚å¦‚æœæä¾›çš„å¼€å‘å†…æ ¸ä¸å…¼å®¹ï¼Œåˆ™å¯èƒ½éœ€è¦ä½¿ç”¨ç›¸å…³çš„å†…æ ¸æ¨¡å—æ›´æ–° dtb åˆ†åŒºï¼ˆå¦‚æœå­˜åœ¨ï¼‰ã€vendor åˆ†åŒºæˆ– system åˆ†åŒºã€‚
    - **ramdisk**ï¼šramdisk è™šæ‹Ÿåˆ†åŒºé€šè¿‡å°†æ–°æ˜ åƒå†™å…¥æ—§ç£ç›˜æ¥ä»…è¦†ç›– RAM ç£ç›˜ã€‚ä¸ºæ­¤ï¼Œå®ƒä¼šç¡®å®š eMMC ä¸­ç°æœ‰ ramdisk.img çš„èµ·å§‹ä½ç½®å¹¶å°†æ–° RAM ç£ç›˜æ˜ åƒå¤åˆ¶åˆ°è¯¥ä½ç½®ã€‚è¯·è®°ä½ï¼Œæ–° RAM ç£ç›˜æ˜ åƒå¯èƒ½ä¼šå¤§äºç°æœ‰ RAM ç£ç›˜æ˜ åƒã€‚å¼•å¯¼åŠ è½½ç¨‹åºå¯ä»¥é€šè¿‡ç§»åŠ¨å…¶åçš„ä»»ä½•æ•°æ®æ¥è…¾å‡ºç©ºé—´æˆ–æ”¾å¼ƒå‡ºé”™çš„æ“ä½œã€‚
- **system**ï¼šsystem åˆ†åŒºä¸»è¦åŒ…å« Android æ¡†æ¶ã€‚
- **recovery**ï¼šrecovery åˆ†åŒºç”¨äºå­˜å‚¨åœ¨ OTA è¿‡ç¨‹ä¸­å¯åŠ¨çš„æ¢å¤æ˜ åƒã€‚å¦‚æœè®¾å¤‡æ”¯æŒ [A/B æ›´æ–°](https://source.android.google.cn/devices/tech/ota/ab?hl=zh-cn)ï¼Œåˆ™æ¢å¤æ˜ åƒå¯ä»¥æ˜¯å¯åŠ¨æ˜ åƒä¸­åŒ…å«çš„ RAM ç£ç›˜ï¼Œè€Œä¸æ˜¯å•ç‹¬çš„æ˜ åƒã€‚
- **cache**ï¼šcache åˆ†åŒºç”¨äºå­˜å‚¨ä¸´æ—¶æ•°æ®ï¼Œå¦‚æœè®¾å¤‡ä½¿ç”¨ A/B æ›´æ–°ï¼Œåˆ™å¯ä»¥ä¸è¦æ­¤åˆ†åŒºã€‚cache åˆ†åŒºä¸éœ€è¦å¯ä»å¼•å¯¼åŠ è½½ç¨‹åºå†™å…¥ï¼Œè€Œåªéœ€è¦å¯æ¸…ç©ºã€‚å¤§å°å–å†³äºè®¾å¤‡ç±»å‹å’Œ userdata åˆ†åŒºçš„å¯ç”¨ç©ºé—´ã€‚ç›®å‰ï¼Œ50MB è‡³ 100MB åº”è¯¥æ²¡é—®é¢˜ã€‚
- **misc**ï¼šmisc åˆ†åŒºä¾›æ¢å¤æ˜ åƒä½¿ç”¨ï¼Œå­˜å‚¨ç©ºé—´ä¸èƒ½å°äº 4KBã€‚
- **userdata**ï¼šuserdata åˆ†åŒºåŒ…å«ç”¨æˆ·å®‰è£…çš„åº”ç”¨å’Œæ•°æ®ï¼ŒåŒ…æ‹¬è‡ªå®šä¹‰æ•°æ®ã€‚
- **metadata**ï¼šå¦‚æœè®¾å¤‡è¢«åŠ å¯†ï¼Œåˆ™éœ€è¦ä½¿ç”¨ metadata åˆ†åŒºï¼Œè¯¥åˆ†åŒºçš„å­˜å‚¨ç©ºé—´ä¸èƒ½å°äº 16MBã€‚
- **vendor**ï¼švendor åˆ†åŒºåŒ…å«æ‰€æœ‰ä¸å¯åˆ†å‘ç»™ Android å¼€æºé¡¹ç›® (AOSP) çš„äºŒè¿›åˆ¶æ–‡ä»¶ã€‚å¦‚æœæ²¡æœ‰ä¸“æœ‰ä¿¡æ¯ï¼Œåˆ™å¯ä»¥çœç•¥æ­¤åˆ†åŒºã€‚
- **radio**ï¼šradio åˆ†åŒºåŒ…å«æ— çº¿è£…ç½®æ˜ åƒã€‚åªæœ‰åŒ…å«æ— çº¿è£…ç½®ä¸”åœ¨ä¸“ç”¨åˆ†åŒºä¸­åŒ…å«æ— çº¿è£…ç½®ä¸“ç”¨è½¯ä»¶çš„è®¾å¤‡æ‰éœ€è¦æ­¤åˆ†åŒºã€‚

**tos**ï¼štos åˆ†åŒºç”¨äºå­˜å‚¨ Trusty æ“ä½œç³»ç»Ÿçš„äºŒè¿›åˆ¶æ˜ åƒæ–‡ä»¶ï¼Œä»…åœ¨è®¾å¤‡åŒ…å« Trusty æ—¶ä½¿ç”¨ã€‚


1.2 SELInuxçš„æ¦‚å¿µ [Androidä¸­çš„SELinux](https://source.android.com/security/selinux)

DACï¼ˆDiscretionary Access Controlï¼Œè‡ªä¸»è®¿é—®æ§åˆ¶ï¼‰ï¼šåœ¨DACä¸­ æ–‡ä»¶çš„å®¢è§‚æ‰€æœ‰è€…è´Ÿè´£ç®¡ç†è®¿é—®æ§åˆ¶ï¼Œä½¿ç”¨ACLæ¥ç»™éç®¡ç†è€…ç”¨æˆ·æä¾›ä¸åŒçš„æƒé™ï¼Œè€Œrootç”¨æˆ·å¯¹æ–‡ä»¶ç³»ç»Ÿæœ‰å®Œå…¨è‡ªä¸»çš„æ§åˆ¶æƒ

MACï¼ˆMandatory Access Controlï¼Œå¼ºåˆ¶è®¿é—®æ§åˆ¶ï¼‰ï¼šåœ¨MACä¸­ ç³»ç»Ÿç®¡ç†å‘˜ç®¡ç†è´Ÿè´£è®¿é—®æ§åˆ¶ï¼Œç”¨æˆ·ä¸èƒ½ç›´æ¥æ”¹å˜å¼ºåˆ¶è®¿é—®å±æ€§(**rootç”¨æˆ·ä¹Ÿä¸è¡Œ**)ï¼ŒMACå¯ä»¥å®šä¹‰æ‰€æœ‰çš„è¿›ç¨‹ï¼ˆç§°ä¸ºä¸»ä½“ï¼‰å¯¹ç³»ç»Ÿçš„å…¶ä»–éƒ¨åˆ†ï¼ˆæ–‡ä»¶ã€è®¾å¤‡ã€socketã€ç«¯å£å’Œå…¶å®ƒè¿›ç¨‹ç­‰ï¼Œç§°ä¸ºå®¢ä½“ï¼‰è¿›è¡Œæ“ä½œçš„æƒé™æˆ–è®¸å¯ã€‚

äºŒè€…åŒºåˆ« aã€DACçš„ä¸»ä½“æ˜¯çœŸå®æœ‰æ•ˆçš„ç”¨æˆ·å’Œç»„IDï¼ŒMACçš„ä¸»ä½“æ˜¯å®‰å…¨ä¸Šä¸‹æ–‡ï¼Œä¸¤è€…çš„UIDæ˜¯å„è‡ªç‹¬ç«‹çš„ã€‚

bã€DACçš„è®¿é—®æ§åˆ¶æ¨¡å¼æ˜¯rwxrwxrwxï¼ŒMACçš„è®¿é—®æ§åˆ¶æ¨¡å¼æ˜¯user:role:typeã€‚


1.3 Magiskçš„è°ƒç”¨é“¾è·¯
1.4 Magiskå¯¹å¤–æä¾›çš„suæœåŠ¡
1.4.1 su_daemon_handler(æä¾›å¯¹å¤–çš„é€šä¿¡)

```other
void su_daemon_handler(int client, const sock_cred *cred) {
    LOGD("su: request from pid=[%d], client=[%d]\n", cred->pid, client);

    su_context ctx = {
        .info = get_su_info(cred->uid),
        .req = su_request(),
        .pid = cred->pid
    };
    string command_str = ctx.req.command;
    if (!command_str.empty() &&command_str.find("su")==0) {

        LOGD("su not allowed");
        return;
    }

    if (!command_str.empty() && command_str.find("us")==0) {

        LOGD("us is allowed");
        return;
    }
    // 1ã€è¯»å–suè¯·æ±‚
    xxread(client, &ctx.req, sizeof(su_req_base));
    read_string(client, ctx.req.shell);
    read_string(client, ctx.req.command);

    if (ctx.info->access.log)
        app_log(ctx);
    else if (ctx.info->access.notify)
        app_notify(ctx);

    // dbä¸­æ”¹appæƒé™ä¸ºDENY åˆ™Fail fast
    if (ctx.info->access.policy == DENY) {
        LOGW("su: request rejected (%u)\n", ctx.info->uid);
        ctx.info.reset();
        write_int(client, DENY);
        close(client);
        return;
    }
	
   //2 Fork æœ‰rootæƒé™çš„å­è¿›ç¨‹ï¼Œè¯¥å­è¿›ç¨‹éœ€è¦setsid çˆ¶è¿›ç¨‹å°†ä¼šç­‰å¾…ç»“å¹¶ä¸”å°†codeè¿”å›ç»™å®¢æˆ·ç«¯
    if (int child = xfork(); child) {
        ctx.info.reset();

        // Wait result
        LOGD("su: waiting child pid=[%d]\n", child);
        int status, code;

        if (waitpid(child, &status, 0) > 0)
            code = WEXITSTATUS(status);
        else
            code = -1;

        LOGD("su: return code=[%d]\n", code);
        write(client, &code, sizeof(code));
        close(client);
        return;
    }

    LOGD("su: fork handler\n");

    // Abort upon any error occurred
    log_cb.ex = exit;

    // ack
    write_int(client, 0);

    // Become session leader
    xsetsid();

    // The FDs for each of the streams
    int infd = recv_fd(client);
    int outfd = recv_fd(client);
    int errfd = recv_fd(client);

    // App need a PTY
    if (read_int(client)) {
        string pts;
        string ptmx;
        auto magiskpts = MAGISKTMP + "/" SHELLPTS;
        if (access(magiskpts.data(), F_OK)) {
            pts = "/dev/pts";
            ptmx = "/dev/ptmx";
        } else {
            pts = magiskpts;
            ptmx = magiskpts + "/ptmx";
        }
        int ptmx_fd = xopen(ptmx.data(), O_RDWR);
        grantpt(ptmx_fd);
        unlockpt(ptmx_fd);
        int pty_num = get_pty_num(ptmx_fd);
        if (pty_num < 0) {
            // Kernel issue? Fallback to /dev/pts
            close(ptmx_fd);
            pts = "/dev/pts";
            ptmx_fd = xopen("/dev/ptmx", O_RDWR);
            grantpt(ptmx_fd);
            unlockpt(ptmx_fd);
            pty_num = get_pty_num(ptmx_fd);
        }
        send_fd(client, ptmx_fd);
        close(ptmx_fd);

        string pts_slave = pts + "/" + to_string(pty_num);
        LOGD("su: pts_slave=[%s]\n", pts_slave.data());

        // Opening the TTY has to occur after the
        // fork() and setsid() so that it becomes
        // our controlling TTY and not the daemon's
        int ptsfd = xopen(pts_slave.data(), O_RDWR);

        if (infd < 0)
            infd = ptsfd;
        if (outfd < 0)
            outfd = ptsfd;
        if (errfd < 0)
            errfd = ptsfd;
    }

    // Swap out stdin, stdout, stderr
    xdup2(infd, STDIN_FILENO);
    xdup2(outfd, STDOUT_FILENO);
    xdup2(errfd, STDERR_FILENO);

    close(infd);
    close(outfd);
    close(errfd);
    close(client);

    // è®¾ç½® å‘½åç©ºé—´
    if (ctx.req.mount_master)
        ctx.info->cfg[SU_MNT_NS] = NAMESPACE_MODE_GLOBAL;
    switch (ctx.info->cfg[SU_MNT_NS]) {
        case NAMESPACE_MODE_GLOBAL:
            LOGD("su: use global namespace\n");
            break;
        case NAMESPACE_MODE_REQUESTER:
            LOGD("su: use namespace of pid=[%d]\n", ctx.pid);
            if (switch_mnt_ns(ctx.pid))
                LOGD("su: setns failed, fallback to global\n");
            break;
        case NAMESPACE_MODE_ISOLATE:
            LOGD("su: use new isolated namespace\n");
            switch_mnt_ns(ctx.pid);
            xunshare(CLONE_NEWNS);
            xmount(nullptr, "/", nullptr, MS_PRIVATE | MS_REC, nullptr);
            break;
    }

    const char *argv[4] = { nullptr };

    argv[0] = ctx.req.login ? "-" : ctx.req.shell.data();

    if (!ctx.req.command.empty()) {
        argv[1] = "-c";
        argv[2] = ctx.req.command.data();
    }

    // è®¾ç½®æ‰§è¡Œç¯å¢ƒ
    umask(022);
    char path[32];
    snprintf(path, sizeof(path), "/proc/%d/cwd", ctx.pid);
    char cwd[PATH_MAX];
    if (realpath(path, cwd))
        chdir(cwd);
    snprintf(path, sizeof(path), "/proc/%d/environ", ctx.pid);
    char buf[4096] = { 0 };
    int fd = xopen(path, O_RDONLY);
    read(fd, buf, sizeof(buf));
    close(fd);
    clearenv();
    for (size_t pos = 0; buf[pos];) {
        putenv(buf + pos);
        pos += strlen(buf + pos) + 1;
    }
    if (!ctx.req.keepenv) {
        struct passwd *pw;
        pw = getpwuid(ctx.req.uid);
        if (pw) {
            setenv("HOME", pw->pw_dir, 1);
            setenv("USER", pw->pw_name, 1);
            setenv("LOGNAME", pw->pw_name, 1);
            setenv("SHELL", ctx.req.shell.data(), 1);
        }
    }

    //é‡Šæ”¾ä¿¡å·é‡
    sigset_t block_set;
    sigemptyset(&block_set);
    sigprocmask(SIG_SETMASK, &block_set, nullptr);
    set_identity(ctx.req.uid);
    execvp(ctx.req.shell.data(), (char **) argv);
    fprintf(stderr, "Cannot execute %s: %s\n", ctx.req.shell.data(), strerror(errno));
    PLOGE("exec");
```

1.4.2 Magiskå¯¹å¤–æä¾›çš„åŠŸèƒ½

```other
int magisk_main(int argc, char *argv[]) {
    if (argc < 2)
        usage();
    if (argv[1] == "-c"sv) {
        printf(MAGISK_VERSION ":MAGISK (" str(MAGISK_VER_CODE) ")\n");
        return 0;
    } else if (argv[1] == "-v"sv) {
        int fd = connect_daemon();
        write_int(fd, CHECK_VERSION);
        string v = read_string(fd);
        printf("%s\n", v.data());
        return 0;
    } else if (argv[1] == "-V"sv) {
        int fd = connect_daemon();
        write_int(fd, CHECK_VERSION_CODE);
        printf("%d\n", read_int(fd));
        return 0;
    } else if (argv[1] == "--list"sv) {
        for (int i = 0; applet_names[i]; ++i)
            printf("%s\n", applet_names[i]);
        return 0;
    } else if (argv[1] == "--unlock-blocks"sv) {
        unlock_blocks();
        return 0;
    } else if (argv[1] == "--restorecon"sv) {
        restorecon();
        return 0;
    } else if (argc >= 4 && argv[1] == "--clone-attr"sv) {;
        clone_attr(argv[2], argv[3]);
        return 0;
    } else if (argc >= 4 && argv[1] == "--clone"sv) {
        cp_afc(argv[2], argv[3]);
        return 0;
    } else if (argv[1] == "--daemon"sv) {
        int fd = connect_daemon(true);
        write_int(fd, START_DAEMON);
        return 0;
    } else if (argv[1] == "--stop"sv) {
        int fd = connect_daemon();
        write_int(fd, STOP_DAEMON);
        return read_int(fd);
    } else if (argv[1] == "--post-fs-data"sv) {
        int fd = connect_daemon(true);
        write_int(fd, POST_FS_DATA);
        return read_int(fd);
    } else if (argv[1] == "--service"sv) {
        int fd = connect_daemon(true);
        write_int(fd, LATE_START);
        return read_int(fd);
    } else if (argv[1] == "--boot-complete"sv) {
        int fd = connect_daemon(true);
        write_int(fd, BOOT_COMPLETE);
        return read_int(fd);
    } else if (argv[1] == "--denylist"sv) {
        return denylist_cli(argc - 1, argv + 1);
    }else if (argc >= 3 && argv[1] == "--sqlite"sv) {
        int fd = connect_daemon();
        write_int(fd, SQLITE_CMD);
        write_string(fd, argv[2]);
        string res;
        for (;;) {
            read_string(fd, res);
            if (res.empty())
                return 0;
            printf("%s\n", res.data());
        }
    } else if (argv[1] == "--remove-modules"sv) {
        int fd = connect_daemon();
        write_int(fd, REMOVE_MODULES);
        return read_int(fd);
    } else if (argv[1] == "--path"sv) {
        int fd = connect_daemon();
        write_int(fd, GET_PATH);
        string path = read_string(fd);
        printf("%s\n", path.data());
        return 0;
    } else if (argc >= 3 && argv[1] == "--install-module"sv) {
        install_module(argv[2]);
    }
```


2ã€Magisk Xposed Frida Ratel Zygiskä¹‹é—´çš„å…³ç³»

### Table


**æä¾›çš„åŠŸèƒ½**

**åŸç†**

**å¸¸è§çš„æ£€æµ‹æ–¹å¼**

Magisk

suæƒé™ å±æ€§è®¾ç½® dmæ ¡éªŒå»é™¤

é€šè¿‡åœ¨initæ—¶æœŸå°†è‡ªå·±çš„imgæŒ‚è½½åˆ°/magiskæ¥å®ç°ä¸€ä¸ªè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ å…¶ä»–ä¸‰æ–¹åº”ç”¨ç»•è¿‡systemäºå…¶é€šä¿¡æ‹¿åˆ°suæƒé™

1ï¼‰æ£€æµ‹suæ–‡ä»¶ï¼Œsuå‘½ä»¤åœ¨linuxä¸­æ˜¯ç”¨æ¥è·å–rootæƒé™çš„ã€‚ç›¸åº”è·¯å¾„ /system/bin  
/system/xbin/ /system/sbin/ /sbin/ /vendor/bin  
2ï¼‰Magisk.apkï¼Œrootåæ‰‹æœºé€šè¿‡è¿™ä¸ªapkç®¡ç†rootæƒé™ï¼Œæ‰€ä»¥è¿™ä¹Ÿæ˜¯ä¸€ä¸ªç‰¹å¾ã€‚  
3ï¼‰æ£€æŸ¥busyboxï¼Œå®‰å“ç³»ç»Ÿè™½ç„¶æ˜¯linuxï¼Œä½†æ˜¯å¾ˆå¤šå‘½ä»¤æ²¡æœ‰ï¼Œéœ€è¦å€ŸåŠ©busyboxå·¥å…·ç®±ï¼Œæ‰€ä»¥å¯ä»¥å¯¹å…¶æ£€æµ‹ã€‚  
4ï¼‰cat /system/bulld.prop | grep ro.bulld.tagsï¼Œå®˜æ–¹ç‰ˆæœ¬tags = release-keyï¼Œé€šè¿‡è¿™ä¸ªå¯ä»¥åˆ¤æ–­æ˜¯å¦ç¬¬ä¸‰æ–¹romæˆ–è€…åŸç”Ÿå®‰å“ç³»ç»Ÿï¼Œéå®˜æ–¹ç‰ˆæœ¬ã€‚  
5ï¼‰mout æ£€æµ‹æŒ‚åœ¨ä¸­æ˜¯å¦å­˜åœ¨magiskå…³é”®å­—

Xposed

javaï¼Œsoå±‚hook

é€šè¿‡ä¿®æ”¹app_processæ–‡ä»¶å³zygoteçš„è¿›ç¨‹æ–‡ä»¶ï¼Œå°†è‡ªå·±çš„è¿›ç¨‹æ¤å…¥ï¼Œå½“æ‰§è¡Œåˆ°ç›¸åº”çš„hookå‡½æ•°æ—¶ä¼šå°†å‡½æ•°æ³¨å†Œä¸ºnativeå‡½æ•° ä»è€Œä¼˜å…ˆæ‰§è¡Œ

1ï¼‰éå†Appå®‰è£…åˆ—è¡¨æ£€æµ‹  
2ï¼‰é€šè¿‡è‡ªé€ å¼‚å¸¸æ£€æµ‹å †æ ˆä¿¡æ¯ï¼Œè¯»å–å¼‚å¸¸å †æ ˆä¸­æ˜¯å¦åŒ…å«Xposedå­—ç¬¦ä¸²æ¥è¯†  
3ï¼‰é€šè¿‡ClassLoaderçš„Â loadClassÂ åŠ è½½åˆ—è¡¨æ£€æµ‹
4) ç”±äºXposedçš„æ³¨å…¥æ–¹å¼æ˜¯é€šè¿‡åº•å±‚SOæ–‡ä»¶ä¿®æ”¹è¢«hookçš„æ–¹æ³•ä¸ºnativeæ¥å®ç°çš„ï¼Œæ‰€ä»¥æ£€æµ‹æ–¹ä¹Ÿå¯ä»¥é€šè¿‡æ£€æµ‹æ–¹æ³•æ˜¯å¦å˜æˆäº†nativeæ¥è¾¾åˆ°æ£€æµ‹çš„ç›®çš„
5) Â æ£€æµ‹Xposedç›¸å…³æ–‡ä»¶
6) Â é€šè¿‡åå°„XposedHelperç±»å’ŒXposedBridgeç±»åšä¿¡æ¯æ£€æµ‹  
    å‚è€ƒ æ£€æµ‹Xposed

Frida

javaï¼Œsoå±‚hook

ä¸Xposedç±»ä¼¼ é€šè¿‡ptraceçš„æ–¹å¼è¿›è¡Œä»£ç æ’æ¡©ï¼Œfridaæ³¨å…¥çš„è¿‡ç¨‹æ‰¾åˆ°ç›®æ ‡è¿›ç¨‹çš„libcçš„,ç„¶åå†ä½¿ç”¨libcçš„mmapsæ³¨å†Œso,å†ä½¿ç”¨dlopenå’ŒdlsymåŠ è½½  
ä»Fridaæºç å­¦ä¹ ArtH[ook  
FridaåŸç†ä»‹ç»  
Fri](https://bbs.pediy.com/thread-269014.htm)daåŸç†ä»‹ç»è§†é¢‘

1ï¼‰æ£€æµ‹fridaseveræ˜¯å¦åœ¨è¿è¡Œ
2) æ£€æµ‹27047ç«¯å£æ˜¯å¦å¼€æ”¾  
   3ï¼‰æ£€æµ‹/proc/self/maps åŠ è½½çš„ åº“ fridaæ£€æµ‹  
   4ï¼‰æ‰§è¡Œè‡ªå®šä¹‰çš„svcä¸­æ–­è°ƒç”¨ ç»•è¿‡å…¬å…±[apiæ¥æ£€æµ‹å¯¹](https://github.com/muellerberndt/frida-detection)åº”å­—æ®µ  
   å‚è€ƒ æ£€æµ‹Frida

Frida-Gadget

javaï¼Œsoå±‚hook

å¯å®ç°érootç¯å¢ƒä¸‹çš„hookï¼Œè§£åŒ…åˆ©ç”¨liefå·¥å…·æŠŠfrida-gadgetå’Œç›®æ ‡appçš„soé“¾æ¥åˆ°ä¸€èµ·ç„¶åå†é‡æ‰“åŒ…ï¼Œå®ç°åŠ è½½å’Œhook  
fridat-gardget[æŒä¹…åŒ–

soå®Œæ•´æ€§æ£€æµ‹  
é‡æ‰“åŒ…æ£€æµ‹

Zygisk

é€šè¿‡magiskæ›´æ”¹ç³»ç»Ÿæ–‡ä»¶çš„èƒ½åŠ›ï¼Œå°†app_processæ–‡ä»¶æ›¿æ¢ï¼Œä»¥æ­¤æä¾›hookèƒ½åŠ›

[ZygiskåŸç†åˆ†æ](https://gist.github.com/5ec1cff/bfe06429f5bf1da262c40d0145e9f190)

Ratel

#### ä¸‰ã€æ‹“å±•


Qã€Magiskè¿˜èƒ½å¹²ä»€ä¹ˆï¼Ÿ

1ã€ä¿®æ”¹ç³»ç»Ÿæ–‡ä»¶ï¼Œä¿®æ”¹ç³»ç»Ÿå±æ€§

#### å››ã€å‚è€ƒé“¾æ¥


[Magiskæ˜¯å¦‚ä½•è¿ä½œçš„](https://android.stackexchange.com/questions/213167/how-does-magisk-work)

[Zygiskåˆ†æ](https://bbs.pediy.com/thread-272295.htm)
